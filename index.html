<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="dist/css/monokai.css">
</head>
<body>
<style>
.full-image {
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    object-fit: cover; /* Ensures the image covers the entire area without distortion */
    transition: scale 1.0s, opacity 0.5s;
    opacity: 1; /* Initial opacity */
}
 .fragment.scaled {
     scale: 1;
     transition: scale 3.0s;
 }
.fragment.scaled.visible {
    scale: 2;
    transition: scale 3.0s;
}
.fragment.no-fade {
    visibility: hidden;
    transition: visibility 0.0s;
}
.fragment.no-fade.visible {
    visibility: visible;
    transition: visibility 0.0s;
}

</style>

<div class="reveal">
    <div class="slides">
        <section class="reveal r-stretch" data-transition="fade"  data-background-image="dist/images/background.png" >
            <div class="title-slide-content">
<!--                <img style="&#45;&#45;r-block-margin: 0; opacity: 1" src="dist/images/background.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image fragment fade-in">-->
                <img id="titleImage" style="--r-block-margin: 0;" src="dist/images/title_card.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image" >
                <div class="fragment fade-in" data-fragment-index="1">
                    <img style="--r-block-margin: 0;" src="dist/images/background.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image">
                    <img style="--r-block-margin: 0;" src="dist/images/background_icon.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image">
                </div>
                <div class="fragment no-fade" data-fragment-index="2">
                    <img style="--r-block-margin: 0;" src="dist/images/background.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image">
                </div>
                <!--                <img style="&#45;&#45;r-block-margin: 0; opacity: 1" src="dist/images/background_icon.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image fragment fade-in-then-out">-->
                <img style="--r-block-margin: 0;" src="dist/images/background_icon.png" alt="Code Generation from Unified Robot Description Format (URDF) for Accelerated Robotics" class="full-image fragment scaled" data-fragment-index="2">
             </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Introduction</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>I am a first time presenter and attender
                    <li>About me: I work as a robotics scientist at PickNik Robotics. I earned my PhD in computer
                        science from the University of New Hampshire on the topic of robot learning from demonstration.
                    <li>I was the primary developer of <code>generate_parameter_library</code>, a ROS 2 library with a
                        declarative syntax for managing parameters
                </ul>
            </div>
        </section>
        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Outline</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Motivate the topic
                    <li>High level code concept for proposal
                    <li>Memory layout and performance
                    <li>Real robot application
                    <li>Summary: lessons learned
                </ul>
            </div>
        </section>


        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Motivation</h2>
            <div class="slide-content">
                <div style="display: flex; flex-direction: column">
                    <div style="text-align: center">
                        <img style="width: 1536px;" src="dist/images/paper.png">
                    </div>
                    <ul class="my-list" style="--spacing: 5vb; margin-top: 5vb">
                        <li>Performance improvements of more than 500x over the state-of-the-art
                        <li>Approach does not require high-power hardware
                        <li>FK implementations commonly use dynamic branching and joint-type polymorphism to compute transforms between link
                        <li>Developed a novel tracing compiler for robot kinematic
                    </ul>
                </div>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Motivation</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb; margin-top: 5vb">
                    <li>Compiler takes in standard Universal Robot Description Format (URDF) files
                    <li>Generates a minimal set of operations required to compute the function
                    <li>e.g. skip unneeded computations like fixed joints, unroll loops, setup data structure to optimize
                        SIMD exzecution
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Motivate the topic</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Some algorithms need to run at incredible speeds for optimal performance
                    <li>This is especially true for common subroutines used by expensive algorithms
                    <li>For example, robot path planning with RRT depends on nearest neighbor lookup and forward
                        kinematics, and collision detection.
                    <li>Reference the Motion planning in micro-seconds paper (not only can you generate fast code, but
                        you can make it algorithmically different, e.g. doing collision check as the FK is done)
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Motivate the topic</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li> Software written by hardware manufactures has an inherit advantage because it can be written
                        with very specific platforms in mind and take advantage of hardware specific knowledge.
                    <li>For example, robot design with spherical wrist can decompose inverse kinematics into two stages
                        1) find the wrist angles to achieve the desired orientation and 2) find the position value
                        needed to find reach the desired Cartesian position.
                    <li>Generic IK solvers cannot take advantage of this kind of knowledge in general
                    <li>One downside of hardware specific implementations is scalability
                    <li>Hardware generally does not change very often, other than attachments, like cameras and end
                        effectors. Take a look at URDF?
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Motivate the topic</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Compiled code can be tested for memory allocations and real-time compatibility (no locks,
                        exceptions, thread switching?). Safety critical applications, such as surgical robots need to
                        meet these requirements
                    <li>Allows for hardware specific CPU optimizations to be enabled since the code is source built on
                        every machine
                    <li>Some advantages of code generation as opposed to a templated robot builder are 1) less likely to
                        make a mistake building defining the robot 2) do not have to maintain code for each of your
                        robot
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Background</h2>
            <div class="slide-content" style="text-align: center">
                <img style="margin-left: 0vb;margin-top: -5vb; width: 1536px;" src="dist/images/sawyer1.png">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Background</h2>
            <div class="slide-content" style="text-align: center">
                <img style="margin-top: -5vb; width: 1536px; position: absolute; transform: translate(-768px, 0);" src="dist/images/sawyer2.png">
                <img class="fragment fade-in" style="margin-top: -5vb;width: 1536px; position: absolute; transform: translate(-768px, 0);" src="dist/images/sawyer3.png">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
                <div class="slide-content" style="text-align: center">
                    <img style="margin-top: -5vb; width: 1536px; position: absolute; transform: translate(-768px, 0);" src="dist/images/demo.gif">
                </div>
        </section>
        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Chart</h2>
            <div class="slide-content">
                <div>
                    <canvas id="myChart"></canvas>
                </div>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">High level code concept for proposal</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Add slides showing how it should work in terms of user code, URDF, and cmake
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Go through example of how it is actually used for a simpler robot</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Show the URDF
                    <li>Show cmake needed to generate the FK library
                    <li>Show how python code is called in cmake and how it parses the URDF and populates Jinja templates
                    <li>Which joint type are supported and how to implement them
                    <li>Show user code that links against it
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
            <div class="slide-content" style="text-align: right">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/fk_eq.png">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-900px, 0);" src="dist/images/jac_1.gif">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
            <div class="slide-content" style="text-align: right">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix.png">
                <img style="margin-top: -5vb; width: 800px; position: absolute; transform: translate(-900px, 0);" src="dist/images/ik.gif">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
            <div class="slide-content" style="text-align: right">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-900px, 0);" src="dist/images/jac_2.gif">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix.png">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix_alpha.png">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
            <div class="slide-content" style="text-align: right">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-900px, 0);" src="dist/images/jac_3.gif">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix.png">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix_alpha_2.png">
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Concept video</h2>
            <div class="slide-content" style="text-align: right">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-900px, 0);" src="dist/images/jac_4.gif">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix.png">
                <img style="margin-top: -5vb; height: 800px; position: absolute; transform: translate(-1550px, 0);" src="dist/images/jac_matrix_alpha_3.png">
            </div>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="language-cmake"><code data-trim data-line-numbers="1-57|3-18">
function(generate_fast_forward_kinematics_library URDF_FILE ROOT_LINK TIP_LINK)

    find_package(Python REQUIRED COMPONENTS Interpreter)
    if (Python_Interpreter_FOUND)
        message(STATUS "Python executable: ${Python_EXECUTABLE}")
    else ()
        message(FATAL_ERROR "Python interpreter not found.")
    endif ()

    execute_process(
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/get_num_joints.py
            ${URDF_FILE}
            ${ROOT_LINK}
            ${TIP_LINK}
            OUTPUT_VARIABLE FAST_FK_NUMBER_OF_JOINTS
            OUTPUT_STRIP_TRAILING_WHITESPACE
            COMMAND_ECHO STDOUT
    )

    include(ExternalProject)
    ExternalProject_Add(
            LBFGSpp
            PREFIX ${CMAKE_BINARY_DIR}/LBFGSpp
            GIT_REPOSITORY https://github.com/yixuan/LBFGSpp.git
            GIT_TAG master
            CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}
    )
    ExternalProject_Get_Property(LBFGSpp source_dir)
    set(LBFGSppIncludeDir ${source_dir}/include)

    add_custom_command(
            OUTPUT forward_kinematics_lib.cpp
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
            ${URDF_FILE}
            ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_lib.cpp
            ${ROOT_LINK}
            ${TIP_LINK}
            DEPENDS ${URDF_FILE} ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            COMMENT
            "Running `${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
                      ${URDF_FILE}
                      ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
                      ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_test.cpp
                      ${ROOT_LINK}
                      ${TIP_LINK}`"
            VERBATIM
    )
    add_custom_target(code_generation DEPENDS forward_kinematics_lib.cpp)

    add_library(fast_forward_kinematics_library SHARED forward_kinematics_lib.cpp)
    add_dependencies(fast_forward_kinematics_library code_generation)
    add_dependencies(fast_forward_kinematics_library LBFGSpp)

    find_package(Eigen3 3.3 NO_MODULE)
    target_compile_definitions(fast_forward_kinematics_library PUBLIC "${FAST_FK_NUMBER_OF_JOINTS}")
    target_include_directories(fast_forward_kinematics_library PUBLIC ${CMAKE_SOURCE_DIR}/include)
    target_include_directories(fast_forward_kinematics_library PUBLIC ${LBFGSppIncludeDir})
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)

endfunction()
















#
          </code></pre>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="python" ><code data-trim data-line-numbers>
from urdf_parser_py import urdf
import argparse


def run():
    parser = argparse.ArgumentParser()
    parser.add_argument('urdf_file')
    parser.add_argument('root_link_name')
    parser.add_argument('tip_link_name')
    args = parser.parse_args()

    root_link_name = args.root_link_name
    tip_link_name = args.tip_link_name
    with open(args.urdf_file) as f:
        robot = urdf.Robot.from_xml_string(f.read())

    joint_names = []
    while tip_link_name != root_link_name:
        tip_joint_name, tip_link_name = robot.parent_map[tip_link_name]
        joint_names.append(tip_joint_name)

    print(f"FAST_FK_NUMBER_OF_JOINTS={len(joint_names)}", end="")


if __name__ == "__main__":
    run()

          </code></pre>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="language-xml" ><code data-trim data-line-numbers="1-761|155-162|162-169|171-178|179-186|186-194|195-202|448-454">
&lt?xml version="1.0" ?&gt
&ltrobot name="ur5e"&gt
  &ltlink name="world"/&gt
  &ltlink name="base_link"/&gt
  &ltlink name="base_link_inertia"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/base.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/base.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="4.0"/&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltinertia ixx="0.00443333156" ixy="0.0" ixz="0.0" iyy="0.00443333156" iyz="0.0" izz="0.0072"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="shoulder_link"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/shoulder.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/shoulder.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="3.7"/&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltinertia ixx="0.010267495893" ixy="0.0" ixz="0.0" iyy="0.010267495893" iyz="0.0" izz="0.00666"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="upper_arm_link"&gt
    &ltvisual&gt
      &ltorigin rpy="1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0.138"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/upperarm.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0.138"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/upperarm.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="8.393"/&gt
      &ltorigin rpy="0 1.5707963267948966 0" xyz="-0.2125 0.0 0.138"/&gt
      &ltinertia ixx="0.1338857818623325" ixy="0.0" ixz="0.0" iyy="0.1338857818623325" iyz="0.0" izz="0.0151074"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="forearm_link"&gt
    &ltvisual&gt
      &ltorigin rpy="1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0.007"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/forearm.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0.007"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/forearm.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="2.275"/&gt
      &ltorigin rpy="0 1.5707963267948966 0" xyz="-0.1961 0.0 0.007"/&gt
      &ltinertia ixx="0.031209355099586295" ixy="0.0" ixz="0.0" iyy="0.031209355099586295" iyz="0.0" izz="0.004095"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="wrist_1_link"&gt
    &ltvisual&gt
      &ltorigin rpy="1.5707963267948966 0 0" xyz="0 0 -0.127"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/wrist1.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="1.5707963267948966 0 0" xyz="0 0 -0.127"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/wrist1.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="1.219"/&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltinertia ixx="0.0025598989760400002" ixy="0.0" ixz="0.0" iyy="0.0025598989760400002" iyz="0.0" izz="0.0021942"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="wrist_2_link"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 0" xyz="0 0 -0.0997"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/wrist2.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 0 -0.0997"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/wrist2.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="1.219"/&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltinertia ixx="0.0025598989760400002" ixy="0.0" ixz="0.0" iyy="0.0025598989760400002" iyz="0.0" izz="0.0021942"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="wrist_3_link"&gt
    &ltvisual&gt
      &ltorigin rpy="1.5707963267948966 0 0" xyz="0 0 -0.0989"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/visual/wrist3.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="1.5707963267948966 0 0" xyz="0 0 -0.0989"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://ur_description/meshes/ur5e/collision/wrist3.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.1879"/&gt
      &ltorigin rpy="0 0 0" xyz="0.0 0.0 -0.0229"/&gt
      &ltinertia ixx="9.890410052167731e-05" ixy="0.0" ixz="0.0" iyy="9.890410052167731e-05" iyz="0.0" izz="0.0001321171875"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &lt!-- base_joint fixes base_link to the environment --&gt
  &ltjoint name="base_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
    &ltparent link="world"/&gt
    &ltchild link="base_link"/&gt
  &lt/joint&gt
  &lt!-- joints - main serial chain --&gt
  &ltjoint name="base_link-base_link_inertia" type="fixed"&gt
    &ltparent link="base_link"/&gt
    &ltchild link="base_link_inertia"/&gt
    &lt!-- 'base_link' is REP-103 aligned (so X+ forward), while the internal
           frames of the robot/controller have X+ pointing backwards.
           Use the joint between 'base_link' and 'base_link_inertia' (a dummy
           link/frame) to introduce the necessary rotation over Z (of pi rad).
      --&gt
    &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltjoint name="shoulder_pan_joint" type="revolute"&gt
    &ltparent link="base_link_inertia"/&gt
    &ltchild link="shoulder_link"/&gt
    &ltorigin rpy="0 0 4.898391345320441e-09" xyz="0 0 0.1625702965797758"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="150.0" lower="-3.141592653589793" upper="3.141592653589793" velocity="0.7853981633974483"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltjoint name="shoulder_lift_joint" type="revolute"&gt
    &ltparent link="shoulder_link"/&gt
    &ltchild link="upper_arm_link"/&gt
    &ltorigin rpy="1.571497675314641 0 3.984082409699119e-06" xyz="0.000182214465989093 0 0"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="150.0" lower="-4.71238898038469" upper="1.5707963267948966" velocity="0.8726646259971648"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltjoint name="elbow_joint" type="revolute"&gt
    &ltparent link="upper_arm_link"/&gt
    &ltchild link="forearm_link"/&gt
    &ltorigin rpy="0.001047955138343435 -0.001169294971873293 4.425876114326764e-06" xyz="-0.4249817627044961 0 0"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="150.0" lower="-3.141592653589793" upper="3.141592653589793" velocity="0.8726646259971648"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltjoint name="wrist_1_joint" type="revolute"&gt
    &ltparent link="forearm_link"/&gt
    &ltchild link="wrist_1_link"/&gt
    &ltorigin rpy="0.007478051175221102 0.0004306268150536495 -7.033675124629128e-06" xyz="-0.3921666446509172 -0.0009975307642066673 0.1333919956383524"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="28.0" lower="-3.141592653589793" upper="3.141592653589793" velocity="3.141592653589793"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltjoint name="wrist_2_joint" type="revolute"&gt
    &ltparent link="wrist_1_link"/&gt
    &ltchild link="wrist_2_link"/&gt
    &ltorigin rpy="1.568983665155081 0 -1.012784017796753e-07" xyz="2.398975523480517e-06 -0.09959821611958637 0.0001805380634879481"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="28.0" lower="-3.141592653589793" upper="3.141592653589793" velocity="3.141592653589793"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltjoint name="wrist_3_joint" type="revolute"&gt
    &ltparent link="wrist_2_link"/&gt
    &ltchild link="wrist_3_link"/&gt
    &ltorigin rpy="1.571939944776703 3.141592653589793 -3.1415926331844" xyz="7.603964784130673e-05 0.09950302422228456 0.0001137934973534554"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltlimit effort="28.0" lower="-3.141592653589793" upper="3.141592653589793" velocity="3.141592653589793"/&gt
    &ltdynamics damping="0" friction="0"/&gt
  &lt/joint&gt
  &ltlink name="ft_frame"/&gt
  &ltjoint name="wrist_3_link-ft_frame" type="fixed"&gt
    &ltparent link="wrist_3_link"/&gt
    &ltchild link="ft_frame"/&gt
    &ltorigin rpy="3.141592653589793 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &lt!-- ROS-Industrial 'base' frame - base_link to UR 'Base' Coordinates transform --&gt
  &ltlink name="base"/&gt
  &ltjoint name="base_link-base_fixed_joint" type="fixed"&gt
    &lt!-- Note the rotation over Z of pi radians - as base_link is REP-103
           aligned (i.e., has X+ forward, Y+ left and Z+ up), this is needed
           to correctly align 'base' with the 'Base' coordinate system of
           the UR controller.
      --&gt
    &ltorigin rpy="0 0 3.141592653589793" xyz="0 0 0"/&gt
    &ltparent link="base_link"/&gt
    &ltchild link="base"/&gt
  &lt/joint&gt
  &lt!-- ROS-Industrial 'flange' frame - attachment point for EEF models --&gt
  &ltlink name="flange"/&gt
  &ltjoint name="wrist_3-flange" type="fixed"&gt
    &ltparent link="wrist_3_link"/&gt
    &ltchild link="flange"/&gt
    &ltorigin rpy="0 -1.5707963267948966 -1.5707963267948966" xyz="0 0 0"/&gt
  &lt/joint&gt
  &lt!-- ROS-Industrial 'tool0' frame - all-zeros tool frame --&gt
  &ltlink name="tool0"/&gt
  &ltjoint name="flange-tool0" type="fixed"&gt
    &lt!-- default toolframe - X+ left, Y+ up, Z+ front --&gt
    &ltorigin rpy="1.5707963267948966 0 1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="flange"/&gt
    &ltchild link="tool0"/&gt
  &lt/joint&gt
  &ltjoint name="tool_changer_joint" type="fixed"&gt
    &lt!-- The parent link must be read from the robot model it is attached to. --&gt
    &ltparent link="tool0"/&gt
    &ltchild link="tool_changer_link"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltlink name="tool_changer_link"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://picknik_accessories/descriptions/brackets/mtc_ur_tool_changer/mtc_ur3510_ur_toolchanger.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://picknik_accessories/descriptions/brackets/mtc_ur_tool_changer/mtc_ur3510_ur_toolchanger_collision.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
  &lt/link&gt
  &ltjoint name="tool_side_joint" type="fixed"&gt
    &ltparent link="tool_changer_link"/&gt
    &ltchild link="tool_changer_tool0"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0.0331"/&gt
  &lt/joint&gt
  &ltlink name="tool_changer_tool0"/&gt
  &ltjoint name="realsense_camera_adapter_joint" type="fixed"&gt
    &lt!-- The parent link must be read from the robot model it is attached to. --&gt
    &ltparent link="tool_changer_tool0"/&gt
    &ltchild link="realsense_camera_adapter_link"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltlink name="realsense_camera_adapter_link"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://picknik_accessories/descriptions/brackets/ur_realsense_camera_adapter/picknik_ur5_realsense_camera_adapter_rev2.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://picknik_accessories/descriptions/brackets/ur_realsense_camera_adapter/picknik_ur5_realsense_camera_adapter_rev2_collision.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
  &lt/link&gt
  &ltlink name="realsense_camera_adapter_tool0"/&gt
  &ltjoint name="realsense_camera_adapter_tool0_joint" type="fixed"&gt
    &ltparent link="realsense_camera_adapter_link"/&gt
    &ltchild link="realsense_camera_adapter_tool0"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0.007"/&gt
  &lt/joint&gt
  &ltlink name="d415_mount_link"/&gt
  &ltjoint name="d415_mount_joint" type="fixed"&gt
    &ltparent link="realsense_camera_adapter_link"/&gt
    &ltchild link="d415_mount_link"/&gt
    &ltorigin rpy="0 -1.4835298641951802 1.5707963267948966" xyz="0 -0.067 0.0171"/&gt
  &lt/joint&gt
  &ltlink name="l515_mount_link"/&gt
  &ltjoint name="l515_mount_joint" type="fixed"&gt
    &ltparent link="realsense_camera_adapter_link"/&gt
    &ltchild link="l515_mount_link"/&gt
    &ltorigin rpy="0 -1.4835298641951802 1.5707963267948966" xyz="0 -0.0406 0.0173"/&gt
  &lt/joint&gt
  &lt!-- camera body, with origin at bottom screw mount --&gt
  &ltjoint name="wrist_mounted_camera_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
    &ltparent link="d415_mount_link"/&gt
    &ltchild link="wrist_mounted_camera_bottom_screw_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_bottom_screw_frame"/&gt
  &ltjoint name="wrist_mounted_camera_link_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0.02 0.0115"/&gt
    &ltparent link="wrist_mounted_camera_bottom_screw_frame"/&gt
    &ltchild link="wrist_mounted_camera_link"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_link"&gt
    &ltvisual&gt
      &ltorigin rpy="1.5707963267948966 0 1.5707963267948966" xyz="0.00987 -0.02 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://realsense2_description/meshes/d415.stl"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 -0.02 0"/&gt
      &ltgeometry&gt
        &ltbox size="0.02005 0.099 0.023"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.072"/&gt
      &lt!-- The following are not reliable values, and should not be used for modeling --&gt
      &ltorigin xyz="0 0 0"/&gt
      &ltinertia ixx="0.003881243" ixy="0.0" ixz="0.0" iyy="0.000498940" iyz="0.0" izz="0.003879257"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &lt!-- camera depth joints and links --&gt
  &ltjoint name="wrist_mounted_camera_depth_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
    &ltparent link="wrist_mounted_camera_link"/&gt
    &ltchild link="wrist_mounted_camera_depth_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_depth_frame"/&gt
  &ltjoint name="wrist_mounted_camera_depth_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="wrist_mounted_camera_depth_frame"/&gt
    &ltchild link="wrist_mounted_camera_depth_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_depth_optical_frame"/&gt
  &lt!-- camera left IR joints and links --&gt
  &ltjoint name="wrist_mounted_camera_infra1_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0.0 0"/&gt
    &ltparent link="wrist_mounted_camera_link"/&gt
    &ltchild link="wrist_mounted_camera_infra1_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_infra1_frame"/&gt
  &ltjoint name="wrist_mounted_camera_infra1_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="wrist_mounted_camera_infra1_frame"/&gt
    &ltchild link="wrist_mounted_camera_infra1_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_infra1_optical_frame"/&gt
  &lt!-- camera right IR joints and links --&gt
  &ltjoint name="wrist_mounted_camera_infra2_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 -0.055 0"/&gt
    &ltparent link="wrist_mounted_camera_link"/&gt
    &ltchild link="wrist_mounted_camera_infra2_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_infra2_frame"/&gt
  &ltjoint name="wrist_mounted_camera_infra2_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="wrist_mounted_camera_infra2_frame"/&gt
    &ltchild link="wrist_mounted_camera_infra2_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_infra2_optical_frame"/&gt
  &lt!-- camera color joints and links --&gt
  &ltjoint name="wrist_mounted_camera_color_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0.015 0"/&gt
    &ltparent link="wrist_mounted_camera_link"/&gt
    &ltchild link="wrist_mounted_camera_color_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_color_frame"/&gt
  &ltjoint name="wrist_mounted_camera_color_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="wrist_mounted_camera_color_frame"/&gt
    &ltchild link="wrist_mounted_camera_color_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="wrist_mounted_camera_color_optical_frame"/&gt
  &ltjoint name="ur_to_robotiq_joint" type="fixed"&gt
    &lt!-- The parent link must be read from the robot model it is attached to. --&gt
    &ltparent link="realsense_camera_adapter_tool0"/&gt
    &ltchild link="ur_to_robotiq_link"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltlink name="ur_to_robotiq_link"&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/ur_to_robotiq_adapter.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/ur_to_robotiq_adapter.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.01"/&gt
      &ltorigin xyz="0 0 0"/&gt
      &ltinertia ixx="0.000044" ixy="0.0" ixz="0.0" iyy="0.000027" iyz="0.0" izz="0.000027"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltjoint name="gripper_side_joint" type="fixed"&gt
    &ltparent link="ur_to_robotiq_link"/&gt
    &ltchild link="gripper_mount_link"/&gt
    &ltorigin rpy="0 -1.5707963267948966 1.5707963267948966" xyz="0 0 0.011"/&gt
  &lt/joint&gt
  &ltlink name="gripper_mount_link"/&gt
  &ltjoint name="robotiq_85_base_joint" type="fixed"&gt
    &ltparent link="gripper_mount_link"/&gt
    &ltchild link="robotiq_85_base_link"/&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltlink name="robotiq_85_base_link"&gt
    &lt!-- Visual aid for grasping --&gt
    &ltvisual&gt
      &ltorigin rpy="0 0 0" xyz="0.16 0 0"/&gt
      &ltgeometry&gt
        &ltsphere radius="0.007"/&gt
      &lt/geometry&gt
      &ltmaterial name=""&gt
        &ltcolor rgba="0 1.0 0 1.0"/&gt
      &lt/material&gt
    &lt/visual&gt
    &lt!-- Gripper body --&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_base_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_base_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.636951"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000380" ixy="0.000000" ixz="0.000000" iyx="0.000000" iyy="0.001110" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.001171"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltjoint name="robotiq_85_left_knuckle_joint" type="revolute"&gt
    &ltparent link="robotiq_85_base_link"/&gt
    &ltchild link="robotiq_85_left_knuckle_link"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltorigin rpy="3.141592653589793 0.0 0.0" xyz="0.05490451627 0.03060114443 0.0"/&gt
    &ltlimit effort="50" lower="0.0" upper="0.804" velocity="0.5"/&gt
    &ltdynamics damping="100.0"/&gt
  &lt/joint&gt
  &ltjoint name="robotiq_85_right_knuckle_joint" type="continuous"&gt
    &ltparent link="robotiq_85_base_link"/&gt
    &ltchild link="robotiq_85_right_knuckle_link"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltorigin rpy="0.0 0.0 0.0" xyz="0.05490451627 -0.03060114443 0.0"/&gt
    &ltlimit effort="50" lower="-3.14" upper="3.14" velocity="100.0"/&gt
    &ltmimic joint="robotiq_85_left_knuckle_joint"/&gt
    &ltdynamics damping="100.0"/&gt
  &lt/joint&gt
  &ltlink name="robotiq_85_left_knuckle_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_knuckle_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_knuckle_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.018491"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000009" ixy="-0.000001" ixz="0.000000" iyx="-0.000001" iyy="0.000001" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000010"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="robotiq_85_right_knuckle_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_knuckle_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_knuckle_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.018491"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000009" ixy="-0.000001" ixz="0.000000" iyx="-0.000001" iyy="0.000001" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000010"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltjoint name="robotiq_85_left_finger_joint" type="fixed"&gt
    &ltparent link="robotiq_85_left_knuckle_link"/&gt
    &ltchild link="robotiq_85_left_finger_link"/&gt
    &ltorigin rpy="0 0 0" xyz="-0.00408552455 -0.03148604435 0.0"/&gt
  &lt/joint&gt
  &ltjoint name="robotiq_85_right_finger_joint" type="fixed"&gt
    &ltparent link="robotiq_85_right_knuckle_link"/&gt
    &ltchild link="robotiq_85_right_finger_link"/&gt
    &ltorigin rpy="0 0 0" xyz="-0.00408552455 -0.03148604435 0.0"/&gt
  &lt/joint&gt
  &ltlink name="robotiq_85_left_finger_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_finger_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_finger_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.027309"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000003" ixy="-0.000002" ixz="0.000000" iyx="-0.000002" iyy="0.000021" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000020"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="robotiq_85_right_finger_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_finger_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_finger_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.027309"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000003" ixy="-0.000002" ixz="0.000000" iyx="-0.000002" iyy="0.000021" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000020"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltjoint name="robotiq_85_left_inner_knuckle_joint" type="continuous"&gt
    &ltparent link="robotiq_85_base_link"/&gt
    &ltchild link="robotiq_85_left_inner_knuckle_link"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltorigin rpy="3.141592653589793 0.0 0.0" xyz="0.06142 0.0127 0"/&gt
    &ltlimit effort="0.1" lower="-3.14" upper="3.14" velocity="100.0"/&gt
    &ltmimic joint="robotiq_85_left_knuckle_joint" offset="0"/&gt
  &lt/joint&gt
  &ltlink name="robotiq_85_left_inner_knuckle_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_inner_knuckle_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_inner_knuckle_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.029951"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000039" ixy="0.000000" ixz="0.000000" iyx="0.000000" iyy="0.000005" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000035"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="robotiq_85_right_inner_knuckle_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_inner_knuckle_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_inner_knuckle_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.029951"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000039" ixy="0.000000" ixz="0.000000" iyx="0.000000" iyy="0.000005" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000035"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltjoint name="robotiq_85_left_finger_tip_joint" type="continuous"&gt
    &ltparent link="robotiq_85_left_inner_knuckle_link"/&gt
    &ltchild link="robotiq_85_left_finger_tip_link"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltorigin rpy="0.0 0.0 0.0" xyz="0.04303959807 -0.03759940821 0.0"/&gt
    &ltlimit effort="0.1" lower="-3.14" upper="3.14" velocity="100.0"/&gt
    &ltmimic joint="robotiq_85_left_knuckle_joint" multiplier="-1"/&gt
  &lt/joint&gt
  &ltjoint name="robotiq_85_right_finger_tip_joint" type="continuous"&gt
    &ltparent link="robotiq_85_right_inner_knuckle_link"/&gt
    &ltchild link="robotiq_85_right_finger_tip_link"/&gt
    &ltaxis xyz="0 0 1"/&gt
    &ltorigin rpy="0.0 0.0 0.0" xyz="0.04303959807 -0.03759940821  0.0"/&gt
    &ltlimit effort="0.1" lower="-3.14" upper="3.14" velocity="100.0"/&gt
    &ltmimic joint="robotiq_85_left_knuckle_joint" multiplier="-1"/&gt
  &lt/joint&gt
  &ltlink name="robotiq_85_left_finger_tip_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_finger_tip_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_finger_tip_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.019555"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000002" ixy="0.000000" ixz="0.000000" iyx="0.000000" iyy="0.000005" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000006"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="robotiq_85_right_finger_tip_link"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/visual/robotiq_85_finger_tip_link.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltmesh filename="package://robotiq_85_description/meshes/collision/robotiq_85_finger_tip_link.stl"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &ltmass value="0.019555"/&gt
      &ltorigin xyz="0.0 0.0 0.0"/&gt
      &ltinertia ixx="0.000002" ixy="0.000000" ixz="0.000000" iyx="0.000000" iyy="0.000005" iyz="0.000000" izx="0.000000" izy="0.000000" izz="0.000006"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &ltlink name="grasp_link"/&gt
  &ltjoint name="grasp_link_joint" type="fixed"&gt
    &ltparent link="gripper_mount_link"/&gt
    &ltchild link="grasp_link"/&gt
    &ltorigin rpy="1.5707963267948966 0.0 1.5707963267948966" xyz="0.134 0.0 0.0"/&gt
  &lt/joint&gt
  &lt!-- Moveit Studio requires a link name called manual_grasp_link to perform quick tasks such as inspect surface --&gt
  &ltlink name="manual_grasp_link"/&gt
  &ltjoint name="manual_grasp_joint" type="fixed"&gt
    &ltparent link="grasp_link"/&gt
    &ltchild link="manual_grasp_link"/&gt
    &ltorigin rpy="0.08726646259971647 0 0" xyz="0 0 0"/&gt
  &lt/joint&gt
  &ltlink name="table"&gt
    &ltvisual&gt
      &ltgeometry&gt
        &ltbox size="2.0 2.0 0.25 "/&gt
      &lt/geometry&gt
      &ltmaterial name="blue"&gt
        &ltcolor rgba="0 0 1 0.3"/&gt
      &lt/material&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltgeometry&gt
        &ltbox size="2.0 2.0  0.25 "/&gt
      &lt/geometry&gt
    &lt/collision&gt
  &lt/link&gt
  &ltjoint name="table" type="fixed"&gt
    &ltparent link="base"/&gt
    &ltchild link="table"/&gt
    &ltorigin rpy="0 0 0" xyz="1.4 0 -0.125"/&gt
  &lt/joint&gt
  &lt!-- Camera External --&gt
  &ltlink name="external_camera_link"/&gt
  &ltjoint name="external_camera_joint" type="fixed"&gt
    &ltparent link="world"/&gt
    &ltchild link="external_camera_link"/&gt
    &ltorigin rpy="0.0 0.4 0" xyz="-0.3 0.3 1.0"/&gt
  &lt/joint&gt
  &lt!-- camera body, with origin at bottom screw mount --&gt
  &ltjoint name="scene_camera_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
    &ltparent link="external_camera_link"/&gt
    &ltchild link="scene_camera_bottom_screw_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_bottom_screw_frame"/&gt
  &ltjoint name="scene_camera_link_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0.010600000000000002 0.0175 0.0125"/&gt
    &ltparent link="scene_camera_bottom_screw_frame"/&gt
    &ltchild link="scene_camera_link"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_link"&gt
    &ltvisual&gt
      &lt!-- the mesh origin is at front plate in between the two infrared camera axes --&gt
      &ltorigin rpy="1.5707963267948966 0 1.5707963267948966" xyz="0.0043 -0.0175 0"/&gt
      &ltgeometry&gt
        &lt!-- &ltbox size="${d435_cam_width} ${d435_cam_height} ${d435_cam_depth}"/&gt --&gt
        &ltmesh filename="package://realsense2_description/meshes/d435.dae"/&gt
      &lt/geometry&gt
    &lt/visual&gt
    &ltcollision&gt
      &ltorigin rpy="0 0 0" xyz="0 -0.0175 0"/&gt
      &ltgeometry&gt
        &ltbox size="0.02505 0.09 0.025"/&gt
      &lt/geometry&gt
    &lt/collision&gt
    &ltinertial&gt
      &lt!-- The following are not reliable values, and should not be used for modeling --&gt
      &ltmass value="0.072"/&gt
      &ltorigin xyz="0 0 0"/&gt
      &ltinertia ixx="0.003881243" ixy="0.0" ixz="0.0" iyy="0.000498940" iyz="0.0" izz="0.003879257"/&gt
    &lt/inertial&gt
  &lt/link&gt
  &lt!-- camera depth joints and links --&gt
  &ltjoint name="scene_camera_depth_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0 0"/&gt
    &ltparent link="scene_camera_link"/&gt
    &ltchild link="scene_camera_depth_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_depth_frame"/&gt
  &ltjoint name="scene_camera_depth_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="scene_camera_depth_frame"/&gt
    &ltchild link="scene_camera_depth_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_depth_optical_frame"/&gt
  &lt!-- camera left IR joints and links --&gt
  &ltjoint name="scene_camera_infra1_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0.0 0"/&gt
    &ltparent link="scene_camera_link"/&gt
    &ltchild link="scene_camera_infra1_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_infra1_frame"/&gt
  &ltjoint name="scene_camera_infra1_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="scene_camera_infra1_frame"/&gt
    &ltchild link="scene_camera_infra1_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_infra1_optical_frame"/&gt
  &lt!-- camera right IR joints and links --&gt
  &ltjoint name="scene_camera_infra2_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 -0.05 0"/&gt
    &ltparent link="scene_camera_link"/&gt
    &ltchild link="scene_camera_infra2_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_infra2_frame"/&gt
  &ltjoint name="scene_camera_infra2_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="scene_camera_infra2_frame"/&gt
    &ltchild link="scene_camera_infra2_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_infra2_optical_frame"/&gt
  &lt!-- camera color joints and links --&gt
  &ltjoint name="scene_camera_color_joint" type="fixed"&gt
    &ltorigin rpy="0 0 0" xyz="0 0.015 0"/&gt
    &ltparent link="scene_camera_link"/&gt
    &ltchild link="scene_camera_color_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_color_frame"/&gt
  &ltjoint name="scene_camera_color_optical_joint" type="fixed"&gt
    &ltorigin rpy="-1.5707963267948966 0 -1.5707963267948966" xyz="0 0 0"/&gt
    &ltparent link="scene_camera_color_frame"/&gt
    &ltchild link="scene_camera_color_optical_frame"/&gt
  &lt/joint&gt
  &ltlink name="scene_camera_color_optical_frame"/&gt
&lt/robot&gt

          </code></pre>
        </section>


        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="language-cmake"><code data-trim data-line-numbers="3-18|20-29|31-49">
function(generate_fast_forward_kinematics_library URDF_FILE ROOT_LINK TIP_LINK)

    find_package(Python REQUIRED COMPONENTS Interpreter)
    if (Python_Interpreter_FOUND)
        message(STATUS "Python executable: ${Python_EXECUTABLE}")
    else ()
        message(FATAL_ERROR "Python interpreter not found.")
    endif ()

    execute_process(
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/get_num_joints.py
            ${URDF_FILE}
            ${ROOT_LINK}
            ${TIP_LINK}
            OUTPUT_VARIABLE FAST_FK_NUMBER_OF_JOINTS
            OUTPUT_STRIP_TRAILING_WHITESPACE
            COMMAND_ECHO STDOUT
    )

    include(ExternalProject)
    ExternalProject_Add(
            LBFGSpp
            PREFIX ${CMAKE_BINARY_DIR}/LBFGSpp
            GIT_REPOSITORY https://github.com/yixuan/LBFGSpp.git
            GIT_TAG master
            CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}
    )
    ExternalProject_Get_Property(LBFGSpp source_dir)
    set(LBFGSppIncludeDir ${source_dir}/include)

    add_custom_command(
            OUTPUT forward_kinematics_lib.cpp
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
            ${URDF_FILE}
            ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_lib.cpp
            ${ROOT_LINK}
            ${TIP_LINK}
            DEPENDS ${URDF_FILE} ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            COMMENT
            "Running `${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
                      ${URDF_FILE}
                      ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
                      ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_test.cpp
                      ${ROOT_LINK}
                      ${TIP_LINK}`"
            VERBATIM
    )
    add_custom_target(code_generation DEPENDS forward_kinematics_lib.cpp)

    add_library(fast_forward_kinematics_library SHARED forward_kinematics_lib.cpp)
    add_dependencies(fast_forward_kinematics_library code_generation)
    add_dependencies(fast_forward_kinematics_library LBFGSpp)

    find_package(Eigen3 3.3 NO_MODULE)
    target_compile_definitions(fast_forward_kinematics_library PUBLIC "${FAST_FK_NUMBER_OF_JOINTS}")
    target_include_directories(fast_forward_kinematics_library PUBLIC ${CMAKE_SOURCE_DIR}/include)
    target_include_directories(fast_forward_kinematics_library PUBLIC ${LBFGSppIncludeDir})
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)

endfunction()
















#
          </code></pre>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="python" ><code class="python" data-trim data-line-numbers="|9-20|22-41|43-49|53-79|82-90">
from jinja2 import Template
from urdf_parser_py import urdf

import argparse
import numpy as np


def run():
    parser = argparse.ArgumentParser()
    parser.add_argument('urdf_file')
    parser.add_argument('fk_template')
    parser.add_argument('fk_output_file')
    parser.add_argument('root_link_name')
    parser.add_argument('tip_link_name')
    args = parser.parse_args()

    root_link_name = args.root_link_name
    tip_link_name = args.tip_link_name
    with open(args.urdf_file) as f:
        robot = urdf.Robot.from_xml_string(f.read())

    def get_transform(joint):
        rpy = joint.origin.rpy
        xyz = joint.origin.xyz
        T = np.eye(4)

        yaw = np.array([[np.cos(rpy[2]), np.sin(rpy[2]), 0],
                        [-np.sin(rpy[2]), np.cos(rpy[2]), 0],
                        [0, 0, 1]])

        pitch = np.array([[np.cos(rpy[1]), 0, np.sin(rpy[1])],
                          [0, 1, 0],
                          [-np.sin(rpy[1]), 0, np.cos(rpy[1])]])

        roll = np.array([[1, 0, 0],
                         [0, np.cos(rpy[0]), np.sin(rpy[0])],
                         [0, -np.sin(rpy[0]), np.cos(rpy[0])]])
        T[:3, :3] = yaw @ pitch @ roll
        T[:3, 3] = xyz

        return T

    rotations = []
    offsets = []
    types = []
    joint_names = []
    while tip_link_name != root_link_name:
        tip_joint_name, tip_link_name = robot.parent_map[tip_link_name]
        joint_names.append(tip_joint_name)

    joint_names.reverse()

    T_fixed = np.eye(4)
    for joint_name in joint_names:
        joint = robot.joint_map[joint_name]
        if joint.type == 'fixed':
            T_fixed = T_fixed * get_transform(joint)
        elif joint.type == 'revolute':
            # TODO: need to add joint limits?
            T = get_transform(joint) @ T_fixed
            T_fixed = np.eye(4)
            rotations.append(T[:3, :3])
            offsets.append(T[:3, 3])
            types.append('revolute')
        elif joint.type == 'continuous':
            T = get_transform(joint) @ T_fixed
            T_fixed = np.eye(4)
            rotations.append(T[:3, :3])
            offsets.append(T[:3, 3])
            types.append('revolute')
        elif joint.type == 'prismatic':
            # TODO: need to add joint limits?
            T = get_transform(joint) @ T_fixed
            T_fixed = np.eye(4)
            rotations.append(T[:3, :3])
            offsets.append(T[:3, 3])
            types.append('prismatic')
        else:
            raise Exception(f"joint type {joint.type} in URDF not supported")

    # truncate near zero values
    offsets = [val * (np.abs(val) &gt 1E-5) for val in offsets]
    rotations = [val * (np.abs(val) &gt 1E-5) for val in rotations]

    with open(args.fk_template, 'r') as f:
        j2_template = Template(f.read())
        code = j2_template.render({'rotations': rotations, 'offsets': offsets, 'types': types}, trim_blocks=True)

    with open(args.fk_output_file, 'w') as f:
        f.write(code)


if __name__ == "__main__":
    run()

          </code></pre>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre><code class="language-cpp" data-trim data-line-numbers>
#include "fast_kinematics.hpp"

namespace fast_fk::internal {
    // sin(t) cos(t)  px py pz R11, R12, R13...
    constexpr int data_size = 2 + 3 + 9+2; // 16

  void forward_kinematics_internal(float *input_data, std::size_t /*size*/) {

      // row major
      constexpr std::array&ltfloat, {{rotations|length}}* 9&gt R_all = {
              {%- for rotation in rotations %}
              {%- for row in rotation %}
              {%- for val in row %} {{val}},
              {%- endfor %}
              {% endfor %}
              {%- endfor -%}
      };

      constexpr std::array&ltfloat, {{rotations|length}}* 3&gt offset_all = {
              {%- for offset in offsets %}
              {%- for val in offset %} {{val}},
              {%- endfor %}
              {% endfor -%}
      };

      float tmp1;
      float tmp2;
      float tmp3;

      {% for type in types %}
      {
          constexpr std::size_t ind = {{loop.index0}};

          // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
          const float &R11_fixed = R_all[ind * 9 + 0];
          const float &R21_fixed = R_all[ind * 9 + 1];
          const float &R31_fixed = R_all[ind * 9 + 2];
          const float &R12_fixed = R_all[ind * 9 + 3];
          const float &R22_fixed = R_all[ind * 9 + 4];
          const float &R32_fixed = R_all[ind * 9 + 5];
          const float &R13_fixed = R_all[ind * 9 + 6];
          const float &R23_fixed = R_all[ind * 9 + 7];
          const float &R33_fixed = R_all[ind * 9 + 8];

          // offset is the offset of joint_i+1 in frame joint_i
          const float &offset_x = offset_all[ind * 3 + 0];
          const float &offset_y = offset_all[ind * 3 + 1];
          const float &offset_z = offset_all[ind * 3 + 2];

          // R is the rotation from joint_i+1 in the base frame (row major)
          float &R11 = input_data[ind * data_size + 5];
          float &R12 = input_data[ind * data_size + 6];
          float &R13 = input_data[ind * data_size + 7];
          float &R21 = input_data[ind * data_size + 8];
          float &R22 = input_data[ind * data_size + 9];
          float &R23 = input_data[ind * data_size + 10];
          float &R31 = input_data[ind * data_size + 11];
          float &R32 = input_data[ind * data_size + 12];
          float &R33 = input_data[ind * data_size + 13];

          {% if type == 'revolute' %}
          const float &sin_theta = input_data[ind * data_size + 0];
          const float &cos_theta = input_data[ind * data_size + 1];
          {% if loop.index0 == 0 %}
          // apply revolute rotation to R_fixed and store in joint to base rotation R
          R11 = R11_fixed * cos_theta + R12_fixed * sin_theta;
          R12 = -R11_fixed * sin_theta + R12_fixed * cos_theta;
          R13 = R13_fixed;
          R21 = R21_fixed * cos_theta + R22_fixed * sin_theta;
          R22 = -R21_fixed * sin_theta + R22_fixed * cos_theta;
          R23 = R23_fixed;
          R31 = R31_fixed * cos_theta + R32_fixed * sin_theta;
          R32 = -R31_fixed * sin_theta + R32_fixed * cos_theta;
          R33 = R33_fixed;

          // rotate offset to be in base frame
          input_data[ind * data_size + 2] = offset_x;
          input_data[ind * data_size + 3] = offset_y;
          input_data[ind * data_size + 4] = offset_z;

          {% else %}
          // R_old is the rotation from joint_i in base frame (column major)
          float &R11_old = input_data[(ind - 1) * data_size + 5];
          float &R12_old = input_data[(ind - 1) * data_size + 6];
          float &R13_old = input_data[(ind - 1) * data_size + 7];
          float &R21_old = input_data[(ind - 1) * data_size + 8];
          float &R22_old = input_data[(ind - 1) * data_size + 9];
          float &R23_old = input_data[(ind - 1) * data_size + 10];
          float &R31_old = input_data[(ind - 1) * data_size + 11];
          float &R32_old = input_data[(ind - 1) * data_size + 12];
          float &R33_old = input_data[(ind - 1) * data_size + 13];

          // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
          float &R11_tmp = input_data[ind * data_size + 5];
          float &R12_tmp = input_data[ind * data_size + 6];
          float &R13_tmp = input_data[ind * data_size + 7];
          float &R21_tmp = input_data[ind * data_size + 8];
          float &R22_tmp = input_data[ind * data_size + 9];
          float &R23_tmp = input_data[ind * data_size + 10];
          float &R31_tmp = input_data[ind * data_size + 11];
          float &R32_tmp = input_data[ind * data_size + 12];
          float &R33_tmp = input_data[ind * data_size + 13];

          // apply revolute rotation to R11_fixed and store in R11_tmp
          R11_tmp = R11_fixed * cos_theta + R12_fixed * sin_theta;
          R12_tmp = -R11_fixed * sin_theta + R12_fixed * cos_theta;
          R13_tmp = R13_fixed;
          R21_tmp = R21_fixed * cos_theta + R22_fixed * sin_theta;
          R22_tmp = -R21_fixed * sin_theta + R22_fixed * cos_theta;
          R23_tmp = R23_fixed;
          R31_tmp = R31_fixed * cos_theta + R32_fixed * sin_theta;
          R32_tmp = -R31_fixed * sin_theta + R32_fixed * cos_theta;
          R33_tmp = R33_fixed;

          // apply R11_old rotation R11_tmp, to make it in base frame
          tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
          tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
          tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
          R11 = tmp1;
          R21 = tmp2;
          R31 = tmp3;
          tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
          tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
          tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
          R12 = tmp1;
          R22 = tmp2;
          R32 = tmp3;
          tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
          tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
          tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
          R13 = tmp1;
          R23 = tmp2;
          R33 = tmp3;

          // p_old is the position of joint_i in base frame
          const float &px_old = input_data[(ind - 1) * data_size + 2];
          const float &py_old = input_data[(ind - 1) * data_size + 3];
          const float &pz_old = input_data[(ind - 1) * data_size + 4];

          // rotate offset to be in base frame and add p_old
          tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
          tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
          tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
          input_data[ind * data_size + 2] = tmp1;
          input_data[ind * data_size + 3] = tmp2;
          input_data[ind * data_size + 4] = tmp3;
          {% endif %}

          {% elif type == 'prismatic' %}
          {% if loop.index0 == 0 %}
          // copy fixed rotation into joint to base rotation
          R11 = R11_fixed;
          R12 = R12_fixed;
          R13 = R13_fixed;
          R21 = R21_fixed;
          R22 = R22_fixed;
          R23 = R23_fixed;
          R31 = R31_fixed;
          R32 = R32_fixed;
          R33 = R33_fixed;

          // add offset and prismatic actuation in base frame
          const float &linear = input_data[ind * data_size + 0];
          input_data[ind * data_size + 2] = R13_fixed * linear + offset_x;
          input_data[ind * data_size + 3] = R23_fixed * linear + offset_y;
          input_data[ind * data_size + 4] = R33_fixed * linear + offset_z;

          {% else %}
          // R_old is the rotation from joint_i in base frame (row major)
          float &R11_old = input_data[(ind - 1) * data_size + 5];
          float &R12_old = input_data[(ind - 1) * data_size + 6];
          float &R13_old = input_data[(ind - 1) * data_size + 7];
          float &R21_old = input_data[(ind - 1) * data_size + 8];
          float &R22_old = input_data[(ind - 1) * data_size + 9];
          float &R23_old = input_data[(ind - 1) * data_size + 10];
          float &R31_old = input_data[(ind - 1) * data_size + 11];
          float &R32_old = input_data[(ind - 1) * data_size + 12];
          float &R33_old = input_data[(ind - 1) * data_size + 13];

          // apply R11_old rotation R11_fixed, to make it in base frame
          tmp1 = R11_old * R11_fixed + R12_old * R21_fixed + R13_old * R31_fixed;
          tmp2 = R21_old * R11_fixed + R22_old * R21_fixed + R23_old * R31_fixed;
          tmp3 = R31_old * R11_fixed + R32_old * R21_fixed + R33_old * R31_fixed;
          R11 = tmp1;
          R21 = tmp2;
          R31 = tmp3;
          tmp1 = R11_old * R12_fixed + R12_old * R22_fixed + R13_old * R32_fixed;
          tmp2 = R21_old * R12_fixed + R22_old * R22_fixed + R23_old * R32_fixed;
          tmp3 = R31_old * R12_fixed + R32_old * R22_fixed + R33_old * R32_fixed;
          R12 = tmp1;
          R22 = tmp2;
          R32 = tmp3;
          tmp1 = R11_old * R13_fixed + R12_old * R23_fixed + R13_old * R33_fixed;
          tmp2 = R21_old * R13_fixed + R22_old * R23_fixed + R23_old * R33_fixed;
          tmp3 = R31_old * R13_fixed + R32_old * R23_fixed + R33_old * R33_fixed;
          R13 = tmp1;
          R23 = tmp2;
          R33 = tmp3;

          // rotate offset to be in base frame
          tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z;
          tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z;
          tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z;

          // add offset, prismatic actuation, and old position in base frame
          const float &px_old = input_data[(ind - 1) * data_size + 2];
          const float &py_old = input_data[(ind - 1) * data_size + 3];
          const float &pz_old = input_data[(ind - 1) * data_size + 4];
          const float &linear = input_data[ind * data_size + 0];
          input_data[ind * data_size + 2] = tmp1 + R13_old * linear + px_old;
          input_data[ind * data_size + 3] = tmp2 + R23_old * linear + py_old;
          input_data[ind * data_size + 4] = tmp3 + R33_old * linear + pz_old;
          {% endif %}
          {% endif %}
      }
      {% endfor %}
  }

}


namespace fast_fk::internal {
    constexpr float axis_scale = 1;

    float InverseKinematics::operator()(const Eigen::VectorX&ltfloat&gt &q, Eigen::VectorX&ltfloat&gt &grad) {
        // construct input_data from q
        float tmp1;
        float tmp2;

        {% for type in types %}
        {% if type == 'revolute' -%}
        tmp1 = q[{{loop.index0}}];
        tmp2 = q[{{loop.index0}}];
        joint_data[{{loop.index0}}][0] = std::sin(tmp1);
        joint_data[{{loop.index0}}][1] = std::cos(tmp2);
        {%- elif type == 'prismatic' -%}
        joint_data[{{loop.index0}}][0] = q[{{loop.index0}}];
        {%- endif %}
        {%- endfor %}

        float *input_data = joint_data.data()-&gtdata();
        internal::forward_kinematics_internal(input_data, data_size * {{rotations | length}});

        Eigen::Vector3&ltfloat&gt target_x_axis_ = target_rot_.block&lt3, 1&gt(0, 0);
        Eigen::Vector3&ltfloat&gt target_y_axis_ = target_rot_.block&lt3, 1&gt(0, 1);
        Eigen::Vector3&ltfloat&gt target_z_axis_ = target_rot_.block&lt3, 1&gt(0, 2);
        Eigen::Vector3&ltfloat&gt target_x_ = target_pose_ + axis_scale * target_x_axis_;
        Eigen::Vector3&ltfloat&gt target_y_ = target_pose_ + axis_scale * target_y_axis_;
        Eigen::Vector3&ltfloat&gt target_z_ = target_pose_ + axis_scale * target_z_axis_;


        Eigen::Vector&ltfloat, 3&gt ee_pose;
        ee_pose &lt&lt input_data[({{ rotations | length }} - 1) *data_size + 2], input_data[({{ rotations | length }} - 1)
        *data_size + 3], input_data[({{ rotations | length }} - 1) *data_size + 4];

        // x point
        Eigen::Vector&ltfloat, 3&gt x_axis;
        x_axis &lt&lt input_data[({{ rotations | length }} - 1) *data_size + 5], input_data[({{ rotations | length }} - 1)
        *data_size + 8], input_data[({{ rotations | length }} - 1) *data_size + 11];
        Eigen::Vector&ltfloat, 3&gt current_x = ee_pose + x_axis;

        // y point
        Eigen::Vector&ltfloat, 3&gt y_axis;
        y_axis &lt&lt input_data[({{ rotations | length }} - 1) *data_size + 6], input_data[({{ rotations | length }} - 1)
        *data_size + 9], input_data[({{ rotations | length }} - 1) *data_size + 12];
        Eigen::Vector&ltfloat, 3&gt current_y = ee_pose + y_axis;

        // z point
        Eigen::Vector&ltfloat, 3&gt z_axis;
        z_axis &lt&lt input_data[({{ rotations | length }} - 1) *data_size + 7], input_data[({{ rotations | length }} - 1)
        *data_size + 10], input_data[({{ rotations | length }} - 1) *data_size + 13];
        Eigen::Vector&ltfloat, 3&gt current_z = ee_pose + z_axis;

        float fx = 0.0;
        Eigen::Vector3&ltfloat&gt delta_x = target_x_.array() - current_x.array();
        Eigen::Vector3&ltfloat&gt delta_y = target_y_.array() - current_y.array();
        Eigen::Vector3&ltfloat&gt delta_z = target_z_.array() - current_z.array();
        fx += (delta_x.array() * delta_x.array()).sum();
        fx += (delta_y.array() * delta_y.array()).sum();
        fx += (delta_z.array() * delta_z.array()).sum();

        // J =  (delta_x)^2
        //    + (delta_y)^2
        //    + (delta_z)^2

        // dJ/dq = dJ1/dq + dJ2/dq + dJ3/dq

        // dJ1/dq = dJ/ddelta_x * ddelta_x/dq
        // dJ2/dq = dJ/ddelta_y * ddelta_y/dq
        // dJ3/dq = dJ/ddelta_z * ddelta_z/dq

        // dJ/ddelta_x : 1x3 2*(x_target - x_current)
        // dJ/ddelta_y : 1x3 2*(y_target - y_current)
        // dJ/ddelta_z : 1x3 2*(z_target - z_current)

        // ddelta_x/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x x_axis
        // ddelta_y/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x y_axis
        // ddelta_z/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x z_axis


        // gradient
        grad *= 0;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_x = 2 * delta_x;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_y = 2 * delta_y;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_z = 2 * delta_z;

        Eigen::Vector&ltfloat, 3&gt joint_pose;
        Eigen::Vector&ltfloat, 3&gt delta;
        Eigen::Vector&ltfloat, 3&gt joint_axis;
        Eigen::Vector&ltfloat, 3&gt jac_linear;
        Eigen::Vector&ltfloat, 3&gt jac_angular;
        Eigen::Vector3&ltfloat&gt ddelta_x_dq_ind;
        Eigen::Vector3&ltfloat&gt ddelta_y_dq_ind;
        Eigen::Vector3&ltfloat&gt ddelta_z_dq_ind;

        {% for type in types %}
        {
            constexpr std::size_t ind = {{loop.index0}};
            {% if type == 'revolute' %}
            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);

            {% elif type == 'prismatic' %}
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            // jac_linear is the joint axis
            // x point
            grad[ind] -= dJ_ddelta_x.dot(joint_axis);

            // y point
            grad[ind] -= dJ_ddelta_y.dot(joint_axis);

            // z point
            grad[ind] -= dJ_ddelta_z.dot(joint_axis);
            {% endif %}
        }
        {% endfor %}

        return fx;
    }


}
          </code></pre>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre><code class="language-cpp" data-trim data-line-numbers>
#include "fast_kinematics.hpp"

namespace fast_fk::internal {
    // sin(t) cos(t)  px py pz R11, R12, R13...
    constexpr int data_size = 2 + 3 + 9+2; // 16

    void forward_kinematics_internal(float *input_data, std::size_t /*size*/) {

        // row major
        constexpr std::array&ltfloat, 6* 9&gt R_all = { -1.0, -0.0, 0.0,
                                                    0.0, -1.0, 0.0,
                                                    0.0, 0.0, 1.0,
                                                    0.9999999999920636, -0.0, 0.0,
                                                    -0.0, -0.0007013484622411433, 0.9999997540472005,
                                                    0.0, -0.999999754055137, -0.0007013484622467095,
                                                    0.9999993163649181, 0.0, -0.001169289425224364,
                                                    -0.0, 0.9999994508798468, 0.0010479601216713834,
                                                    0.001169294705420077, -0.00104795423012248, 0.9999987672701519,
                                                    0.9999999072555382, -1.0253697707014652e-05, 0.00043056216350321623,
                                                    0.0, 0.9999720394582239, 0.0074779845070412285,
                                                    -0.0004306268017444494, -0.007477980785065483, 0.9999719467884766,
                                                    0.9999999999999949, -0.0, -0.0,
                                                    0.0, 0.001812660647159262, 0.9999983571293345,
                                                    0.0, -0.9999983571293396, 0.0018126606471592713,
                                                    0.9999999999999998, 0.0, -0.0,
                                                    -0.0, 0.0011436177325240319, -0.9999993460690269,
                                                    -0.0, 0.9999993460690271, 0.001143617732524032,
        };

        constexpr std::array&ltfloat, 6* 3&gt offset_all = { 0.0, 0.0, 0.1625702965797758,
                                                         0.000182214465989093, 0.0, 0.0,
                                                         -0.4249817627044961, 0.0, 0.0,
                                                         -0.3921666446509172, -0.0009975307642066673, 0.1333919956383524,
                                                         0.0, -0.09959821611958637, 0.0001805380634879481,
                                                         7.603964784130673e-05, 0.09950302422228456, 0.0001137934973534554,
        };

        float tmp1;
        float tmp2;
        float tmp3;


        {
            constexpr std::size_t ind = 0;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // apply revolute rotation to R_fixed and store in joint to base rotation R
            R11 = R11_fixed * cos_t + R12_fixed * sin_t;
            R12 = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13 = R13_fixed;
            R21 = R21_fixed * cos_t + R22_fixed * sin_t;
            R22 = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23 = R23_fixed;
            R31 = R31_fixed * cos_t + R32_fixed * sin_t;
            R32 = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33 = R33_fixed;

            // rotate offset to be in base frame
            input_data[ind * data_size + 2] = offset_x;
            input_data[ind * data_size + 3] = offset_y;
            input_data[ind * data_size + 4] = offset_z;




        }

        {
            constexpr std::size_t ind = 1;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // R_old is the rotation from joint_i in base frame (column major)
            float &R11_old = input_data[(ind - 1) * data_size + 5];
            float &R12_old = input_data[(ind - 1) * data_size + 6];
            float &R13_old = input_data[(ind - 1) * data_size + 7];
            float &R21_old = input_data[(ind - 1) * data_size + 8];
            float &R22_old = input_data[(ind - 1) * data_size + 9];
            float &R23_old = input_data[(ind - 1) * data_size + 10];
            float &R31_old = input_data[(ind - 1) * data_size + 11];
            float &R32_old = input_data[(ind - 1) * data_size + 12];
            float &R33_old = input_data[(ind - 1) * data_size + 13];

            // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
            float &R11_tmp = input_data[ind * data_size + 5];
            float &R12_tmp = input_data[ind * data_size + 6];
            float &R13_tmp = input_data[ind * data_size + 7];
            float &R21_tmp = input_data[ind * data_size + 8];
            float &R22_tmp = input_data[ind * data_size + 9];
            float &R23_tmp = input_data[ind * data_size + 10];
            float &R31_tmp = input_data[ind * data_size + 11];
            float &R32_tmp = input_data[ind * data_size + 12];
            float &R33_tmp = input_data[ind * data_size + 13];

            // apply revolute rotation to R11_fixed and store in R11_tmp
            R11_tmp = R11_fixed * cos_t + R12_fixed * sin_t;
            R12_tmp = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13_tmp = R13_fixed;
            R21_tmp = R21_fixed * cos_t + R22_fixed * sin_t;
            R22_tmp = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23_tmp = R23_fixed;
            R31_tmp = R31_fixed * cos_t + R32_fixed * sin_t;
            R32_tmp = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33_tmp = R33_fixed;

            // apply R11_old rotation R11_tmp, to make it in base frame
            tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
            tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
            tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
            R11 = tmp1;
            R21 = tmp2;
            R31 = tmp3;
            tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
            tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
            tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
            R12 = tmp1;
            R22 = tmp2;
            R32 = tmp3;
            tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
            tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
            tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
            R13 = tmp1;
            R23 = tmp2;
            R33 = tmp3;

            // p_old is the position of joint_i in base frame
            const float &px_old = input_data[(ind - 1) * data_size + 2];
            const float &py_old = input_data[(ind - 1) * data_size + 3];
            const float &pz_old = input_data[(ind - 1) * data_size + 4];

            // rotate offset to be in base frame and add p_old
            tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
            tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
            tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
            input_data[ind * data_size + 2] = tmp1;
            input_data[ind * data_size + 3] = tmp2;
            input_data[ind * data_size + 4] = tmp3;



        }

        {
            constexpr std::size_t ind = 2;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // R_old is the rotation from joint_i in base frame (column major)
            float &R11_old = input_data[(ind - 1) * data_size + 5];
            float &R12_old = input_data[(ind - 1) * data_size + 6];
            float &R13_old = input_data[(ind - 1) * data_size + 7];
            float &R21_old = input_data[(ind - 1) * data_size + 8];
            float &R22_old = input_data[(ind - 1) * data_size + 9];
            float &R23_old = input_data[(ind - 1) * data_size + 10];
            float &R31_old = input_data[(ind - 1) * data_size + 11];
            float &R32_old = input_data[(ind - 1) * data_size + 12];
            float &R33_old = input_data[(ind - 1) * data_size + 13];

            // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
            float &R11_tmp = input_data[ind * data_size + 5];
            float &R12_tmp = input_data[ind * data_size + 6];
            float &R13_tmp = input_data[ind * data_size + 7];
            float &R21_tmp = input_data[ind * data_size + 8];
            float &R22_tmp = input_data[ind * data_size + 9];
            float &R23_tmp = input_data[ind * data_size + 10];
            float &R31_tmp = input_data[ind * data_size + 11];
            float &R32_tmp = input_data[ind * data_size + 12];
            float &R33_tmp = input_data[ind * data_size + 13];

            // apply revolute rotation to R11_fixed and store in R11_tmp
            R11_tmp = R11_fixed * cos_t + R12_fixed * sin_t;
            R12_tmp = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13_tmp = R13_fixed;
            R21_tmp = R21_fixed * cos_t + R22_fixed * sin_t;
            R22_tmp = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23_tmp = R23_fixed;
            R31_tmp = R31_fixed * cos_t + R32_fixed * sin_t;
            R32_tmp = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33_tmp = R33_fixed;

            // apply R11_old rotation R11_tmp, to make it in base frame
            tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
            tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
            tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
            R11 = tmp1;
            R21 = tmp2;
            R31 = tmp3;
            tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
            tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
            tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
            R12 = tmp1;
            R22 = tmp2;
            R32 = tmp3;
            tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
            tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
            tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
            R13 = tmp1;
            R23 = tmp2;
            R33 = tmp3;

            // p_old is the position of joint_i in base frame
            const float &px_old = input_data[(ind - 1) * data_size + 2];
            const float &py_old = input_data[(ind - 1) * data_size + 3];
            const float &pz_old = input_data[(ind - 1) * data_size + 4];

            // rotate offset to be in base frame and add p_old
            tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
            tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
            tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
            input_data[ind * data_size + 2] = tmp1;
            input_data[ind * data_size + 3] = tmp2;
            input_data[ind * data_size + 4] = tmp3;



        }

        {
            constexpr std::size_t ind = 3;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // R_old is the rotation from joint_i in base frame (column major)
            float &R11_old = input_data[(ind - 1) * data_size + 5];
            float &R12_old = input_data[(ind - 1) * data_size + 6];
            float &R13_old = input_data[(ind - 1) * data_size + 7];
            float &R21_old = input_data[(ind - 1) * data_size + 8];
            float &R22_old = input_data[(ind - 1) * data_size + 9];
            float &R23_old = input_data[(ind - 1) * data_size + 10];
            float &R31_old = input_data[(ind - 1) * data_size + 11];
            float &R32_old = input_data[(ind - 1) * data_size + 12];
            float &R33_old = input_data[(ind - 1) * data_size + 13];

            // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
            float &R11_tmp = input_data[ind * data_size + 5];
            float &R12_tmp = input_data[ind * data_size + 6];
            float &R13_tmp = input_data[ind * data_size + 7];
            float &R21_tmp = input_data[ind * data_size + 8];
            float &R22_tmp = input_data[ind * data_size + 9];
            float &R23_tmp = input_data[ind * data_size + 10];
            float &R31_tmp = input_data[ind * data_size + 11];
            float &R32_tmp = input_data[ind * data_size + 12];
            float &R33_tmp = input_data[ind * data_size + 13];

            // apply revolute rotation to R11_fixed and store in R11_tmp
            R11_tmp = R11_fixed * cos_t + R12_fixed * sin_t;
            R12_tmp = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13_tmp = R13_fixed;
            R21_tmp = R21_fixed * cos_t + R22_fixed * sin_t;
            R22_tmp = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23_tmp = R23_fixed;
            R31_tmp = R31_fixed * cos_t + R32_fixed * sin_t;
            R32_tmp = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33_tmp = R33_fixed;

            // apply R11_old rotation R11_tmp, to make it in base frame
            tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
            tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
            tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
            R11 = tmp1;
            R21 = tmp2;
            R31 = tmp3;
            tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
            tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
            tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
            R12 = tmp1;
            R22 = tmp2;
            R32 = tmp3;
            tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
            tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
            tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
            R13 = tmp1;
            R23 = tmp2;
            R33 = tmp3;

            // p_old is the position of joint_i in base frame
            const float &px_old = input_data[(ind - 1) * data_size + 2];
            const float &py_old = input_data[(ind - 1) * data_size + 3];
            const float &pz_old = input_data[(ind - 1) * data_size + 4];

            // rotate offset to be in base frame and add p_old
            tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
            tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
            tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
            input_data[ind * data_size + 2] = tmp1;
            input_data[ind * data_size + 3] = tmp2;
            input_data[ind * data_size + 4] = tmp3;



        }

        {
            constexpr std::size_t ind = 4;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // R_old is the rotation from joint_i in base frame (column major)
            float &R11_old = input_data[(ind - 1) * data_size + 5];
            float &R12_old = input_data[(ind - 1) * data_size + 6];
            float &R13_old = input_data[(ind - 1) * data_size + 7];
            float &R21_old = input_data[(ind - 1) * data_size + 8];
            float &R22_old = input_data[(ind - 1) * data_size + 9];
            float &R23_old = input_data[(ind - 1) * data_size + 10];
            float &R31_old = input_data[(ind - 1) * data_size + 11];
            float &R32_old = input_data[(ind - 1) * data_size + 12];
            float &R33_old = input_data[(ind - 1) * data_size + 13];

            // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
            float &R11_tmp = input_data[ind * data_size + 5];
            float &R12_tmp = input_data[ind * data_size + 6];
            float &R13_tmp = input_data[ind * data_size + 7];
            float &R21_tmp = input_data[ind * data_size + 8];
            float &R22_tmp = input_data[ind * data_size + 9];
            float &R23_tmp = input_data[ind * data_size + 10];
            float &R31_tmp = input_data[ind * data_size + 11];
            float &R32_tmp = input_data[ind * data_size + 12];
            float &R33_tmp = input_data[ind * data_size + 13];

            // apply revolute rotation to R11_fixed and store in R11_tmp
            R11_tmp = R11_fixed * cos_t + R12_fixed * sin_t;
            R12_tmp = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13_tmp = R13_fixed;
            R21_tmp = R21_fixed * cos_t + R22_fixed * sin_t;
            R22_tmp = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23_tmp = R23_fixed;
            R31_tmp = R31_fixed * cos_t + R32_fixed * sin_t;
            R32_tmp = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33_tmp = R33_fixed;

            // apply R11_old rotation R11_tmp, to make it in base frame
            tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
            tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
            tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
            R11 = tmp1;
            R21 = tmp2;
            R31 = tmp3;
            tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
            tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
            tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
            R12 = tmp1;
            R22 = tmp2;
            R32 = tmp3;
            tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
            tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
            tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
            R13 = tmp1;
            R23 = tmp2;
            R33 = tmp3;

            // p_old is the position of joint_i in base frame
            const float &px_old = input_data[(ind - 1) * data_size + 2];
            const float &py_old = input_data[(ind - 1) * data_size + 3];
            const float &pz_old = input_data[(ind - 1) * data_size + 4];

            // rotate offset to be in base frame and add p_old
            tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
            tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
            tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
            input_data[ind * data_size + 2] = tmp1;
            input_data[ind * data_size + 3] = tmp2;
            input_data[ind * data_size + 4] = tmp3;



        }

        {
            constexpr std::size_t ind = 5;

            // R_fixed is the rotation from joint_i+1 in frame joint_i (row major)
            const float &R11_fixed = R_all[ind * 9 + 0];
            const float &R21_fixed = R_all[ind * 9 + 1];
            const float &R31_fixed = R_all[ind * 9 + 2];
            const float &R12_fixed = R_all[ind * 9 + 3];
            const float &R22_fixed = R_all[ind * 9 + 4];
            const float &R32_fixed = R_all[ind * 9 + 5];
            const float &R13_fixed = R_all[ind * 9 + 6];
            const float &R23_fixed = R_all[ind * 9 + 7];
            const float &R33_fixed = R_all[ind * 9 + 8];

            // offset is the offset of joint_i+1 in frame joint_i
            const float &offset_x = offset_all[ind * 3 + 0];
            const float &offset_y = offset_all[ind * 3 + 1];
            const float &offset_z = offset_all[ind * 3 + 2];

            // R is the rotation from joint_i+1 in the base frame (row major)
            float &R11 = input_data[ind * data_size + 5];
            float &R12 = input_data[ind * data_size + 6];
            float &R13 = input_data[ind * data_size + 7];
            float &R21 = input_data[ind * data_size + 8];
            float &R22 = input_data[ind * data_size + 9];
            float &R23 = input_data[ind * data_size + 10];
            float &R31 = input_data[ind * data_size + 11];
            float &R32 = input_data[ind * data_size + 12];
            float &R33 = input_data[ind * data_size + 13];


            const float &sin_t = input_data[ind * data_size + 0];
            const float &cos_t = input_data[ind * data_size + 1];

            // R_old is the rotation from joint_i in base frame (column major)
            float &R11_old = input_data[(ind - 1) * data_size + 5];
            float &R12_old = input_data[(ind - 1) * data_size + 6];
            float &R13_old = input_data[(ind - 1) * data_size + 7];
            float &R21_old = input_data[(ind - 1) * data_size + 8];
            float &R22_old = input_data[(ind - 1) * data_size + 9];
            float &R23_old = input_data[(ind - 1) * data_size + 10];
            float &R31_old = input_data[(ind - 1) * data_size + 11];
            float &R32_old = input_data[(ind - 1) * data_size + 12];
            float &R33_old = input_data[(ind - 1) * data_size + 13];

            // R_tmp is the rotation from joint_i+1 in frame joint_i after rotation applied (column major)
            float &R11_tmp = input_data[ind * data_size + 5];
            float &R12_tmp = input_data[ind * data_size + 6];
            float &R13_tmp = input_data[ind * data_size + 7];
            float &R21_tmp = input_data[ind * data_size + 8];
            float &R22_tmp = input_data[ind * data_size + 9];
            float &R23_tmp = input_data[ind * data_size + 10];
            float &R31_tmp = input_data[ind * data_size + 11];
            float &R32_tmp = input_data[ind * data_size + 12];
            float &R33_tmp = input_data[ind * data_size + 13];

            // apply revolute rotation to R11_fixed and store in R11_tmp
            R11_tmp = R11_fixed * cos_t + R12_fixed * sin_t;
            R12_tmp = -R11_fixed * sin_t + R12_fixed * cos_t;
            R13_tmp = R13_fixed;
            R21_tmp = R21_fixed * cos_t + R22_fixed * sin_t;
            R22_tmp = -R21_fixed * sin_t + R22_fixed * cos_t;
            R23_tmp = R23_fixed;
            R31_tmp = R31_fixed * cos_t + R32_fixed * sin_t;
            R32_tmp = -R31_fixed * sin_t + R32_fixed * cos_t;
            R33_tmp = R33_fixed;

            // apply R11_old rotation R11_tmp, to make it in base frame
            tmp1 = R11_old * R11_tmp + R12_old * R21_tmp + R13_old * R31_tmp;
            tmp2 = R21_old * R11_tmp + R22_old * R21_tmp + R23_old * R31_tmp;
            tmp3 = R31_old * R11_tmp + R32_old * R21_tmp + R33_old * R31_tmp;
            R11 = tmp1;
            R21 = tmp2;
            R31 = tmp3;
            tmp1 = R11_old * R12_tmp + R12_old * R22_tmp + R13_old * R32_tmp;
            tmp2 = R21_old * R12_tmp + R22_old * R22_tmp + R23_old * R32_tmp;
            tmp3 = R31_old * R12_tmp + R32_old * R22_tmp + R33_old * R32_tmp;
            R12 = tmp1;
            R22 = tmp2;
            R32 = tmp3;
            tmp1 = R11_old * R13_tmp + R12_old * R23_tmp + R13_old * R33_tmp;
            tmp2 = R21_old * R13_tmp + R22_old * R23_tmp + R23_old * R33_tmp;
            tmp3 = R31_old * R13_tmp + R32_old * R23_tmp + R33_old * R33_tmp;
            R13 = tmp1;
            R23 = tmp2;
            R33 = tmp3;

            // p_old is the position of joint_i in base frame
            const float &px_old = input_data[(ind - 1) * data_size + 2];
            const float &py_old = input_data[(ind - 1) * data_size + 3];
            const float &pz_old = input_data[(ind - 1) * data_size + 4];

            // rotate offset to be in base frame and add p_old
            tmp1 = R11_old * offset_x + R12_old * offset_y + R13_old * offset_z + px_old;
            tmp2 = R21_old * offset_x + R22_old * offset_y + R23_old * offset_z + py_old;
            tmp3 = R31_old * offset_x + R32_old * offset_y + R33_old * offset_z + pz_old;
            input_data[ind * data_size + 2] = tmp1;
            input_data[ind * data_size + 3] = tmp2;
            input_data[ind * data_size + 4] = tmp3;



        }

    }

}


namespace fast_fk::internal {
    constexpr float axis_scale = 1;

    float InverseKinematics::operator()(const Eigen::VectorX&ltfloat&gt &q, Eigen::VectorX&ltfloat&gt &grad) {
        // construct input_data from q
        float tmp1;
        float tmp2;


        tmp1 = q[0];
        tmp2 = q[0];
        joint_data[0][0] = std::sin(tmp1);
        joint_data[0][1] = std::cos(tmp2);
        tmp1 = q[1];
        tmp2 = q[1];
        joint_data[1][0] = std::sin(tmp1);
        joint_data[1][1] = std::cos(tmp2);
        tmp1 = q[2];
        tmp2 = q[2];
        joint_data[2][0] = std::sin(tmp1);
        joint_data[2][1] = std::cos(tmp2);
        tmp1 = q[3];
        tmp2 = q[3];
        joint_data[3][0] = std::sin(tmp1);
        joint_data[3][1] = std::cos(tmp2);
        tmp1 = q[4];
        tmp2 = q[4];
        joint_data[4][0] = std::sin(tmp1);
        joint_data[4][1] = std::cos(tmp2);
        tmp1 = q[5];
        tmp2 = q[5];
        joint_data[5][0] = std::sin(tmp1);
        joint_data[5][1] = std::cos(tmp2);

        float *input_data = joint_data.data()-&gtdata();
        internal::forward_kinematics_internal(input_data, data_size * 6);

        Eigen::Vector3&ltfloat&gt target_x_axis_ = target_rot_.block&lt3, 1&gt(0, 0);
        Eigen::Vector3&ltfloat&gt target_y_axis_ = target_rot_.block&lt3, 1&gt(0, 1);
        Eigen::Vector3&ltfloat&gt target_z_axis_ = target_rot_.block&lt3, 1&gt(0, 2);
        Eigen::Vector3&ltfloat&gt target_x_ = target_pose_ + axis_scale * target_x_axis_;
        Eigen::Vector3&ltfloat&gt target_y_ = target_pose_ + axis_scale * target_y_axis_;
        Eigen::Vector3&ltfloat&gt target_z_ = target_pose_ + axis_scale * target_z_axis_;


        Eigen::Vector&ltfloat, 3&gt ee_pose;
        ee_pose &lt&lt input_data[(6 - 1) *data_size + 2], input_data[(6 - 1)
                                                                  *data_size + 3], input_data[(6 - 1) *data_size + 4];

        // x point
        Eigen::Vector&ltfloat, 3&gt x_axis;
        x_axis &lt&lt input_data[(6 - 1) *data_size + 5], input_data[(6 - 1)
                                                                 *data_size + 8], input_data[(6 - 1) *data_size + 11];
        Eigen::Vector&ltfloat, 3&gt current_x = ee_pose + x_axis;

        // y point
        Eigen::Vector&ltfloat, 3&gt y_axis;
        y_axis &lt&lt input_data[(6 - 1) *data_size + 6], input_data[(6 - 1)
                                                                 *data_size + 9], input_data[(6 - 1) *data_size + 12];
        Eigen::Vector&ltfloat, 3&gt current_y = ee_pose + y_axis;

        // z point
        Eigen::Vector&ltfloat, 3&gt z_axis;
        z_axis &lt&lt input_data[(6 - 1) *data_size + 7], input_data[(6 - 1)
                                                                 *data_size + 10], input_data[(6 - 1) *data_size + 13];
        Eigen::Vector&ltfloat, 3&gt current_z = ee_pose + z_axis;

        float fx = 0.0;
        Eigen::Vector3&ltfloat&gt delta_x = target_x_.array() - current_x.array();
        Eigen::Vector3&ltfloat&gt delta_y = target_y_.array() - current_y.array();
        Eigen::Vector3&ltfloat&gt delta_z = target_z_.array() - current_z.array();
        fx += (delta_x.array() * delta_x.array()).sum();
        fx += (delta_y.array() * delta_y.array()).sum();
        fx += (delta_z.array() * delta_z.array()).sum();

        // J =  (delta_x)^2
        //    + (delta_y)^2
        //    + (delta_z)^2

        // dJ/dq = dJ1/dq + dJ2/dq + dJ3/dq

        // dJ1/dq = dJ/ddelta_x * ddelta_x/dq
        // dJ2/dq = dJ/ddelta_y * ddelta_y/dq
        // dJ3/dq = dJ/ddelta_z * ddelta_z/dq

        // dJ/ddelta_x : 1x3 2*(x_target - x_current)
        // dJ/ddelta_y : 1x3 2*(y_target - y_current)
        // dJ/ddelta_z : 1x3 2*(z_target - z_current)

        // ddelta_x/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x x_axis
        // ddelta_y/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x y_axis
        // ddelta_z/dq: 3 x dofs J_{:3,:} + dofs J_{3:,:} x z_axis


        // gradient
        grad *= 0;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_x = 2 * delta_x;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_y = 2 * delta_y;
        Eigen::Vector3&ltfloat&gt dJ_ddelta_z = 2 * delta_z;

        Eigen::Vector&ltfloat, 3&gt joint_pose;
        Eigen::Vector&ltfloat, 3&gt delta;
        Eigen::Vector&ltfloat, 3&gt joint_axis;
        Eigen::Vector&ltfloat, 3&gt jac_linear;
        Eigen::Vector&ltfloat, 3&gt jac_angular;
        Eigen::Vector3&ltfloat&gt ddelta_x_dq_ind;
        Eigen::Vector3&ltfloat&gt ddelta_y_dq_ind;
        Eigen::Vector3&ltfloat&gt ddelta_z_dq_ind;


        {
            constexpr std::size_t ind = 0;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }

        {
            constexpr std::size_t ind = 1;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }

        {
            constexpr std::size_t ind = 2;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }

        {
            constexpr std::size_t ind = 3;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }

        {
            constexpr std::size_t ind = 4;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }

        {
            constexpr std::size_t ind = 5;

            joint_pose[0] = input_data[ind * data_size + 2];
            joint_pose[1] = input_data[ind * data_size + 3];
            joint_pose[2] = input_data[ind * data_size + 4];
            delta = ee_pose - joint_pose;
            joint_axis[0] = input_data[ind * data_size + 7];
            joint_axis[1] = input_data[ind * data_size + 10];
            joint_axis[2] = input_data[ind * data_size + 13];
            jac_linear = joint_axis.cross(delta);
            jac_angular = joint_axis;

            // x point
            ddelta_x_dq_ind = jac_linear + jac_angular.cross(axis_scale * x_axis);
            grad[ind] -= dJ_ddelta_x.dot(ddelta_x_dq_ind);

            // y point
            ddelta_y_dq_ind = jac_linear + jac_angular.cross(axis_scale * y_axis);
            grad[ind] -= dJ_ddelta_y.dot(ddelta_y_dq_ind);

            // z point
            ddelta_z_dq_ind = jac_linear + jac_angular.cross(axis_scale * z_axis);
            grad[ind] -= dJ_ddelta_z.dot(ddelta_z_dq_ind);


        }


        return fx;
    }


}
          </code></pre>
        </section>




        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="language-cmake"><code data-trim data-line-numbers="31-49|51-53|55-60">
function(generate_fast_forward_kinematics_library URDF_FILE ROOT_LINK TIP_LINK)

    find_package(Python REQUIRED COMPONENTS Interpreter)
    if (Python_Interpreter_FOUND)
        message(STATUS "Python executable: ${Python_EXECUTABLE}")
    else ()
        message(FATAL_ERROR "Python interpreter not found.")
    endif ()

    execute_process(
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/get_num_joints.py
            ${URDF_FILE}
            ${ROOT_LINK}
            ${TIP_LINK}
            OUTPUT_VARIABLE FAST_FK_NUMBER_OF_JOINTS
            OUTPUT_STRIP_TRAILING_WHITESPACE
            COMMAND_ECHO STDOUT
    )

    include(ExternalProject)
    ExternalProject_Add(
            LBFGSpp
            PREFIX ${CMAKE_BINARY_DIR}/LBFGSpp
            GIT_REPOSITORY https://github.com/yixuan/LBFGSpp.git
            GIT_TAG master
            CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}
    )
    ExternalProject_Get_Property(LBFGSpp source_dir)
    set(LBFGSppIncludeDir ${source_dir}/include)

    add_custom_command(
            OUTPUT forward_kinematics_lib.cpp
            COMMAND ${Python_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
            ${URDF_FILE}
            ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_lib.cpp
            ${ROOT_LINK}
            ${TIP_LINK}
            DEPENDS ${URDF_FILE} ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
            COMMENT
            "Running `${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/scripts/robot_gen.py
                      ${URDF_FILE}
                      ${CMAKE_SOURCE_DIR}/scripts/robot_config.cpp.template
                      ${CMAKE_CURRENT_BINARY_DIR}/forward_kinematics_test.cpp
                      ${ROOT_LINK}
                      ${TIP_LINK}`"
            VERBATIM
    )
    add_custom_target(code_generation DEPENDS forward_kinematics_lib.cpp)

    add_library(fast_forward_kinematics_library SHARED forward_kinematics_lib.cpp)
    add_dependencies(fast_forward_kinematics_library code_generation)
    add_dependencies(fast_forward_kinematics_library LBFGSpp)

    find_package(Eigen3 3.3 NO_MODULE)
    target_compile_definitions(fast_forward_kinematics_library PUBLIC "${FAST_FK_NUMBER_OF_JOINTS}")
    target_include_directories(fast_forward_kinematics_library PUBLIC ${CMAKE_SOURCE_DIR}/include)
    target_include_directories(fast_forward_kinematics_library PUBLIC ${LBFGSppIncludeDir})
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)
    target_link_libraries(fast_forward_kinematics_library PUBLIC Eigen3::Eigen)

endfunction()
















#
          </code></pre>
        </section>


        <section class="reveal r-stretch" data-transition="none"  data-background-image="dist/images/background.png" >
            <div class="title-slide-content">
                <img style="--r-block-margin: 0;" src="dist/images/cmake1.gif" class="full-image" >
          </div>
        </section>
        <section class="reveal r-stretch" data-transition="none"  data-background-image="dist/images/background.png" >
            <div class="title-slide-content">
                <img style="--r-block-margin: 0;" src="dist/images/cmake2.gif" class="full-image" >
            </div>
        </section>
        <section class="reveal r-stretch" data-transition="none"  data-background-image="dist/images/background.png" >
            <div class="title-slide-content">
                <img style="--r-block-margin: 0;" src="dist/images/cmake3.gif" class="full-image" >
            </div>
        </section>



        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Memory layout and performance</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>The general strategy is to minimize cache misses and branching
                    <li>Take advantage of cache lines
                    <li>Explain some basics of FK matrix math
                    <li>Show different layout and there corresponding `perf` values
                    <li>show godbolt.org assembly output
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Real robot application</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>record `perf` value and compare to existing KDL
                    <li>Compare to KDL when compiled from source with native optimizations
                    <li>Dynamic dispatch vs. compile-time dispatch
                    <li>repeat for both FK and IK
                    <li>Show FK queries per second with CUDA generated code
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title">Summary: lessons learned</h2>
            <div class="slide-content">
                <ul class="my-list" style="--spacing: 5vb;">
                    <li>Leverage compile time optimization when needed in common robotics subroutines
                    <li>Leverage code generation to squeeze out as much performance as possible from both the CPU
                        optimizations and known hardware kinematic description.
                </ul>
            </div>
        </section>

        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre><code class="language-cpp" data-trim data-line-numbers>
// row major
constexpr std::array&ltfloat, 56&gt R_all = {
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0,
            // more rows
        };


int main(int argc, char *argv[]) {
    int i = 0;
    return 0 + i; // Why?
}


int main(int argc, char *argv[]) {
    int i = 0;
    return 0 + i; // Why?
}
          </code></pre>
        </section>
        <section class="reveal r-stretch code"  data-transition="fade" data-background-image="dist/images/background.png" >
          <pre class="language-cmake"><code data-trim data-line-numbers="1-4|6-25|26-33">
cmake_minimum_required(VERSION 3.22)
project(fast_forward_kinematics)

set(CMAKE_CXX_STANDARD 20)

generate_fast_forward_kinematics_library(
        ${CMAKE_SOURCE_DIR}/test/ur5.urdf
        base_link ee_link
)
target_compile_options(fast_forward_kinematics_library
        PRIVATE -O3 -mavx2)

add_executable(forward_kinematics_test
               forward_kinematics_test.cpp
)
target_link_libraries(forward_kinematics_test PRIVATE
                      fast_forward_kinematics_library
)
# why ???
add_executable(forward_kinematics_test
        forward_kinematics_test.cpp
)
target_link_libraries(forward_kinematics_test PRIVATE
        fast_forward_kinematics_library
)
# How
# When?





# What?

          </code></pre>
        </section>

        <section class="reveal r-stretch" data-transition="fade" data-background-image="dist/images/background.png" >
            <h2 class="title" style="margin-top: 20vb">Thank you!</h2>
            <h2 class="title" style="margin-top: 20vb">Questions?</h2>
        </section>
    </div>
</div>



<script src="dist/reveal.js"></script>
<script src="dist/notes/notes.js"></script>
<script src="dist/markdown/markdown.js"></script>
<link rel="stylesheet" href="dist/css/monokai.css"/>
<script src="dist/highlight/highlight.js"></script>
<!--<script src="plugin/highlight/plugin.js"></script>-->
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        margin: 0,    // set margin to 0 for 1:1 scale
        minScale: 1.0,  // Ensure slides are not scaled below 1.0
        maxScale: 1.0,  // Ensure slides are not scaled above 1.0
        width: 1920,
        height: 1080,
        hash: true,
        slideNumber: true,
        transitionSpeed: 'fast',
        highlight: {
            highlightOnLoad: true,
        },
        // backgroundTransition: 'slide',
        background: {
            image: 'dist/images/title_card.png',
            size: 'cover', // to cover the entire slide
            position: 'center', // to center the image
            repeat: 'repeat' // to avoid repeating the image
        },
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    }).then(() => {
        const highlight = Reveal.getPlugin('highlight');
        console.log(highlight.hljs.listLanguages())
    });
</script>
<script>
    const elems = document.querySelectorAll('.language-cmake .hljs-variable')
    // console.log(elems)
    elems.forEach((elem, index)=>{
        elem.innerHTML = elem.innerHTML.slice(2, elem.innerHTML.length - 1)
        });
    const elems_cpp = document.querySelectorAll('.language-cpp .hljs-keyword')
    elems_cpp.forEach((elem, index)=>{
        console.log(elem.innerHTML)

        if (elem.innerHTML==='include'){
            elem.className = '.language-cpp .hljs-meta'
        }
    });

</script>


<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
    const ctx = document.getElementById('myChart');
    Chart.defaults.font.size = 45;

    const plugin = {
        id: 'customCanvasBackgroundColor',
        beforeDraw: (chart, args, options) => {
            const {ctx} = chart;
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = options.color || '#99ffff';
            ctx.fillRect(0, 0, chart.width, chart.height);
            ctx.restore();
        }
    };

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Test 1', 'Test 2', 'Test 3', 'Test 4'],
            datasets: [{
                data: [12, 19, 3, 5],
                borderWidth: 1
            },
            {
                data: [12, 19, 3, 5],
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                y: {
                    beginAtZero: true
                }
            },
            plugins: {
                customCanvasBackgroundColor: {
                    color: 'white',
                },
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    text: 'Runtime Comparison (nano seconds)'
                }
            }
        },
        plugins: [plugin],
    });
</script>
</body>
</html>